local json = require "lib.json"
if Domain == nil then
  Domain = require "lib.Domain"
end
if Network == nil then
  Network = require "lib.Network"
end
if Host == nil then
  Host = require "lib.Host"
end

local map_convertor = {}

function render_networks(networks)
  for i,network in ipairs(networks) do
    local flag_too_close = true
    local rand_range = Network.RadisMin
    local network_number = i-1
    while flag_too_close do
      if network_number == 0 then
        network.ui.abs_x = math.random(rand_range)
        network.ui.abs_y = math.random(rand_range)
      else
        network.ui.abs_x = Network.all[network_number].ui.abs_x + math.random(rand_range*2) - rand_range
        network.ui.abs_y = Network.all[network_number].ui.abs_y + math.random(rand_range*2) - rand_range
      end
      flag_too_close = false
      for j=1,i-1 do
        local other_network = networks[j]
        local dist_sqr = math.pow(other_network.ui.abs_x - network.ui.abs_x, 2) + math.pow(other_network.ui.abs_y - network.ui.abs_y, 2)
        if dist_sqr < math.pow(Network.RadisMin, 2) then
          flag_too_close = true
          break
        end
      end
      rand_range = rand_range * 1.5
    end
    network.ui.x = network.ui.abs_x
    network.ui.y = network.ui.abs_y
  end
end

function render_hosts(hosts)
  for i,host in ipairs(hosts) do
    local flag_too_close = true
    local rand_range = 250
    local host_number = #(Host.all)
    while flag_too_close do
      host.ui.abs_x = host.network_interfaces[1].network.ui.abs_x+math.random(rand_range*2)-rand_range
      host.ui.abs_y = host.network_interfaces[1].network.ui.abs_y+math.random(rand_range*2)-rand_range
      host.ui:SetPos(host.ui.abs_x, host.ui.abs_y)
      flag_too_close = false
      for j=1,i-1 do
        local other_host = hosts[j]
        local dist_sqr = math.pow(other_host.ui.abs_x - host.ui.abs_x, 2) + math.pow(other_host.ui.abs_y - host.ui.abs_y, 2)
        if dist_sqr < math.pow(Host.RadisMin, 2) then
          flag_too_close = true
          break
        end
      end
      rand_range = rand_range * 1.5
    end
  end
end

function render_map(tmp_map)
  render_networks(tmp_map.networks)
  render_hosts(tmp_map.hosts)
end

function map_convertor:encode(tmp_map)
  json_map_str = {}
  json_map_str.domains = {}
  json_map_str.networks = {}
  json_map_str.hosts = {}
  for domain_index, domain in ipairs(tmp_map.domains) do
    json_map_str.domains[#(json_map_str.domains)+1] = domain:to_json()
  end
  for network_index, network in ipairs(tmp_map.networks) do
    json_map_str.networks[#(json_map_str.networks)+1] = network:to_json()
  end
  for host_index, host in ipairs(tmp_map.hosts) do
    json_map_str.hosts[#(json_map_str.hosts)+1] = host:to_json(tmp_map.networks)
  end
  return json:encode(json_map_str)
end

function map_convertor:decode(json_map_str)
  json_map = json:decode(json_map_str)
  local tmp_map = {}
  tmp_map.domains = {}
  tmp_map.networks = {}
  tmp_map.hosts = {}
  for domain_index, domain_json in ipairs(json_map.domains) do
    tmp_map.domains[domain_index] = Domain.from_json(domain_json)
  end
  for network_index, network_json in ipairs(json_map.networks) do
    tmp_map.networks[network_index] = Network.from_json(network_json)
  end
  for host_index, host_json in ipairs(json_map.hosts) do
    tmp_map.hosts[host_index] = Host.from_json(host_json, tmp_map.networks)
  end
  render_map(tmp_map)
  return tmp_map
end

return map_convertor