require "lib.util"
if Rootkit == nil then
  Rootkit = require "lib.Rootkit"
end
if Tool == nil then
  Tool = require "lib.Tool"
end
if Virus == nil then
  Virus = require "lib.Virus"
end
if AddrPortListenningService == nil then
  AddrPortListenningService = require "lib.AddrPortListenningService"
end
if Os == nil then
  Os = require "lib.Os"
end
if Tool == nil then
  Tool = require "lib.Tool"
end
if Service == nil then
  Service = require "lib.Service"
end
if Configuration == nil then
  Configuration = require "lib.Configuration"
end
if NetworkInterface == nil then
  NetworkInterface = require "lib.NetworkInterface"
end

local Host = {}
Host.__index = Host
Host.RadisMin = 100
Host.all = {}

Host.State = {}
Host.State.Mine = 0
Host.State.Undiscovered = 1
Host.State.Discovered = 2
Host.State.Compromised = 3
Host.State.RootAccess = 4

Host.Type = {}
Host.Type.Server = 0
Host.Type.Desktop = 1
Host.Type.Laptop = 2
Host.Type.Mobile = 3
Host.Type.Tablet = 4

function Host.new(hostname, state, os, type)
  local self = setmetatable({}, Host)
  self.hostname = hostname
  self.state = nil
  self.selected = false
  self.os = os
  self.configurations = {}
  self.network_interfaces = {}
  self.services = {}
  self.addr_port_listenning_services = {}
  self.viruses = {}
  self.rootkits = {}
  self.tools = {}
  self.type = type
  self.ui = loveframes.Create("imagebutton")--, game.play.map_panel)
  self.ui:SetState("play")
  self.ui:SetText(self.hostname)
  self.ui.OnClick = function(object)
    if game.selected_host then
      game.selected_host.selected = false
      game.selected_host:set_image()
    end
    game.selected_host = self
    self.selected = true
    self:set_image()
    game.play.elements.ip_label:SetVisible(true)
    local info_str = self.hostname
    for _,network_interface in ipairs(self.network_interfaces) do
      info_str = info_str .. " | " .. network_interface.ip
    end
    game.play.elements.ip_text:SetText(info_str)
    game.play.elements.ip_text:SetVisible(true)

    if self.state == Host.State.Mine or self.state == Host.State.Compromised or self.state == Host.State.RootAccess then
      game.play.elements.tools_label:SetVisible(true)
      game.play.elements.tools_multichoice:SetVisible(true)
      for _,tool in ipairs(self.tools) do
        game.play.elements.tools_multichoice:AddChoice(tool.name)
      end
    else
      game.play.elements.tools_label:SetVisible(false)
      game.play.elements.tools_multichoice:SetVisible(false)
      game.play.elements.tools_multichoice:Clear()
    end
    game.play.elements.actions_label:SetVisible(false)
    game.play.elements.actions_multichoice:SetVisible(false)
    game.play.elements.actions_multichoice:Clear()
    game.play.elements.target_label:SetVisible(false)
    game.play.elements.target_input:SetVisible(false)
    game.play.elements.target_input:Clear()
    game.play.elements.command_label:SetVisible(false)
    game.play.elements.command_text:SetVisible(false)
    game.play.elements.run_button:SetVisible(false)
  end
  self:set_state(state)
  Host.all[#(Host.all)+1] = self
  return self
end

function Host:set_state(new_state)
  if new_state == Host.State.Undiscovered then
    self.ui:SetVisible(false)
  else
    self.ui:SetVisible(true)
  end
  self.state = new_state
  self:set_image()
end

function Host:set_image()
  image_path = "images/"

  if self.type == Host.Type.Server then
   image_path = image_path .. "server"
  elseif self.type == Host.Type.Desktop then
   image_path = image_path .. "desktop"
  elseif self.type == Host.Type.Laptop then
   image_path = image_path .. "laptop"
  elseif self.type == Host.Type.Mobile then
   image_path = image_path .. "mobile"
  elseif self.type == Host.Type.Tablet then
   image_path = image_path .. "tablet"
  else

  end

  if self.state == Host.State.Mine then
    image_path = image_path .. "_" .. "mine"
  elseif self.state == Host.State.Compromised or self.state == Host.State.RootAccess then
    image_path = image_path .. "_" .. "compromised"
  else

  end

  if self.selected then
   image_path = image_path .. "_selected"
  end
  image_path = image_path .. ".png"
  self.ui:SetImage(image_path)
  self.ui:SizeToImage()
end

function Host:get_state()
  return self.state
end

function Host:install(program)
  if program.__index == Virus then
    self.viruses[#(self.viruses)+1] = program
  elseif program.__index == Rootkit then
    self.rootkits[#(self.rootkits)+1] = program
  elseif program.__index == Tool then
    self.tools[#(self.tools)+1] = program
  end
end

function Host:attach_network_interface(network_interface)
  self.network_interfaces[#(self.network_interfaces)+1] = network_interface
  network_interface.host = self
end

function Host:add_service(service)
  self.services[#(self.services)+1] = service
  return service
end

function Host:add_configuration(configuration)
  self.configurations[#(self.configurations)+1] = configuration
  return configuration
end

function Host:add_addr_port_listenning_service(network_interface, protocol, port, service)
  addr_port_listenning_service = AddrPortListenningService.new(network_interface, protocol, port, service)
  self.addr_port_listenning_services[#(self.addr_port_listenning_services)+1] = addr_port_listenning_service
end

function Host:reachable_hosts()
  reachable_hosts = {self}
  for index, network_interface in ipairs(self.network_interfaces) do
    if network_interface.network then
      for cni_index, cni in ipairs(network_interface.network.connected_network_interfaces) do
        reachable_hosts[#(reachable_hosts)+1] = cni.host
      end
    end
  end
  return reachable_hosts
end

function Host:get_reachable_host_by_ip(ip)
  if ip == "127.0.0.1" then
    return self
  end
  for index, network_interface in ipairs(self.network_interfaces) do
    if network_interface.network and network_interface.network:has_ip(ip) then
      for cni_index, cni in ipairs(network_interface.network.connected_network_interfaces) do
        if cni.ip == ip then
          return cni.host
        end
      end
    end
  end
  return nil
end

function Host:run(action, target_host, skip_reachable_validation)
  if skip_reachable_validation then
    return action.outcome.eval(target_host)
  end
  flag_target_unreachable = true
  for index, reachable_host in ipairs(self:reachable_hosts()) do
    if target_host == reachable_host then
      flag_target_unreachable = false
      break
    end
  end
  if flag_target_unreachable then
    return "Destination not reachable!"
  end
  return action.outcome.eval(target_host)
end

function Host:run_against_cidr(action, CIDR)
  local splited_cidr = CIDR:split("/")
  local routing_prefix_bits = tonumber(splited_cidr[2])
  local network_prefix = get_network_prefix(splited_cidr[1], routing_prefix_bits)
  local hosts_nubmer = math.pow(2, 32-routing_prefix_bits)
  result_string = ""
  for i=0,hosts_nubmer-1 do
    local target_ip = number_to_ip(network_prefix+i)
    local target_host = self:get_reachable_host_by_ip(target_ip)
    if target_host then
      result = Host:run(action, target_host, true)
      if result then
        result_string = result_string .. "\n" .. result
      end
    else
      result_string = result_string .. "\nDestination (" .. target_ip .. ") not reachable!"
    end
  end
  return result_string
end

function Host:to_json(map_networks)
  local host = {}
  host.hostname = self.hostname
  host.state = self.state
  host.type = self.type
  host.os = {}
  host.os.name = self.os.name
  host.os.version = self.os.version
  host.configurations = {}
  for index, configuration in ipairs(self.configurations) do
    host.configurations[index] = {}
    host.configurations[index].name = configuration.name
  end
  host.network_interfaces = {}
  for index, network_interface in ipairs(self.network_interfaces) do
    host.network_interfaces[index] = {}
    host.network_interfaces[index].ip = network_interface.ip
    for map_network_index, map_network in ipairs(map_networks) do
      if network_interface.network == map_network then
        host.network_interfaces[index].network_index = map_network_index
        break
      end
    end
  end
  host.services = {}
  for index, service in ipairs(self.services) do
    host.services[index] = {}
    host.services[index].name = service.name
    host.services[index].version = service.version
  end
  host.addr_port_listenning_services = {}
  for index, addr_port_listenning_service in ipairs(self.addr_port_listenning_services) do
    host.addr_port_listenning_services[index] = {}
    host.addr_port_listenning_services[index].protocol = addr_port_listenning_service.protocol
    host.addr_port_listenning_services[index].port = addr_port_listenning_service.port
    for network_interface_index, network_interface in ipairs(self.network_interfaces) do
      if addr_port_listenning_service.network_interface == network_interface then
        host.addr_port_listenning_services[index].network_interface_index = network_interface_index
        break
      end
    end
    for service_index, service in ipairs(self.services) do
      if addr_port_listenning_service.service == service then
        host.addr_port_listenning_services[index].service_index = service_index
        break
      end
    end
  end
  host.viruses = {}
  for index, virus in ipairs(self.viruses) do
    host.viruses[index] = {}
    host.viruses[index].name = virus.name
    host.viruses[index].version = virus.version
  end
  host.rootkits = {}
  for index, rootkit in ipairs(self.rootkits) do
    host.rootkits[index] = {}
    host.rootkits[index].name = rootkit.name
    host.rootkits[index].version = rootkit.version
  end
  host.tools = {}
  for index, tool in ipairs(self.tools) do
    host.tools[index] = {}
    host.tools[index].name = tool.name
  end
  return host
end

function Host.from_json(host_json, map_networks)
  local os = Os.lookup(host_json.os.name, host_json.os.version)
  local host = Host.new(host_json.hostname, host_json.state, os, host_json.type)
  host.configurations = {}
  for index, configuration_json in ipairs(host_json.configurations) do
    host.configurations[index] = Configuration.lookup(configuration_json.name)
  end
  host.network_interfaces = {}
  for index, network_interface_json in ipairs(host_json.network_interfaces) do
    local network_interface = NetworkInterface.new()
    network_interface:assign(map_networks[network_interface_json.network_index], network_interface_json.ip)
    host:attach_network_interface(network_interface)
  end
  host.services = {}
  for index, service_json in ipairs(host_json.services) do
    host.services[index] = Service.lookup(service_json.name, service_json.version)
  end
  host.addr_port_listenning_services = {}
  for index, addr_port_listenning_service_json in ipairs(host_json.addr_port_listenning_services) do
    host.addr_port_listenning_services[index] = AddrPortListenningService.new(
      host.network_interfaces[addr_port_listenning_service_json.network_interface_index],
      addr_port_listenning_service_json.protocol,
      addr_port_listenning_service_json.port,
      host.services[addr_port_listenning_service_json.service_index]
    )
  end
  host.viruses = {}
  for index, virus_json in ipairs(host_json.viruses) do
    host.viruses[index] = Virus.lookup(virus_json.name, virus_json.version)
  end
  host.rootkits = {}
  for index, rootkit_json in ipairs(host_json.rootkits) do
    host.rootkits[index] = Rootkit.lookup(rootkit_json.name, rootkit_json.version)
  end
  host.tools = {}
  for index, tool_json in ipairs(host_json.tools) do
    host.tools[index] = Tool.lookup(tool_json.name)
  end
  return host
end

return Host