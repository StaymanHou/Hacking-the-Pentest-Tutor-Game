require "lib.util"

local Network = {}
Network.__index = Network
Network.RadisMin = 350
Network.all = {}

function Network.new(CIDR)
  local self = setmetatable({}, Network)
  local splited_cidr = CIDR:split("/")
  self.routing_prefix_bits = tonumber(splited_cidr[2])
  self.network_prefix = get_network_prefix(splited_cidr[1], self.routing_prefix_bits)
  self.CIDR = number_to_ip(self.network_prefix) .. "/" .. tostring(self.routing_prefix_bits)
  self.connected_network_interfaces = {}
  self.ui = {}
  local flag_too_close = true
  local rand_range = Network.RadisMin
  local network_number = #(Network.all)
  while flag_too_close do
    if network_number == 0 then
      self.ui.x = math.random(rand_range)
      self.ui.y = math.random(rand_range)
    else
      self.ui.x = Network.all[network_number].ui.x + math.random(rand_range*2) - rand_range
      self.ui.y = Network.all[network_number].ui.y + math.random(rand_range*2) - rand_range
    end
    flag_too_close = false
    for _,network in ipairs(Network.all) do
      if network ~= self then
        local dist_sqr = math.pow(network.ui.x - self.ui.x, 2) + math.pow(network.ui.y - self.ui.y, 2)
        if dist_sqr < math.pow(Network.RadisMin, 2) then
          flag_too_close = true
          break
        end
      end
    end
    rand_range = rand_range * 1.5
  end
  Network.all[#(Network.all)+1] = self
  return self
end

function Network:get_cidr()
  return self.CIDR
end

function Network:has_ip(ip)
  if self.network_prefix == get_network_prefix(ip, self.routing_prefix_bits) then
    return true
  else
    return false
  end
end

function Network:get_mask()
  local mask = ""
  local mask_bits = self.routing_prefix_bits
  if mask_bits <= 8 then
    return (math.pow(2, mask_bits)-1) .. ".0.0.0"
  elseif mask_bits <= 16 then
    return "255." .. (math.pow(2, mask_bits-8)-1) .. ".0.0"
  elseif mask_bits <= 24 then
    return "255.255." .. (math.pow(2, mask_bits-16)-1) .. ".0"
  else
    return "255.255.255" .. (math.pow(2, mask_bits-24)-1)
  end
end

function Network:to_json()
  network = {}
  network.CIDR = self.CIDR
  return network
end

function Network.from_json(network_json)
  return Network.new(network_json.CIDR)
end

return Network
